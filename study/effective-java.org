#+title:effective-java
** 目录
*** 考虑使用静态工厂方法代替构造方法
**** 静态工厂方法可以通过选择名字体现差异，更易于理解
**** 可以直接调用，无需事先创建对象
**** 可以返回 返回类型 的任何子类型对象
API可以返回对象而不需要公开它的类，从而隐藏实现类
**** 返回对象的类可以根据输入参数的不同而不同 
根据需要来选择合适的类来生成返回对象，从而优化性能
*** 构造方法参数过多时使用builder模式
*** 使用私有构造方法或枚举类实现singleton属性
**** 公共属性方法
- 单例是公共final 静态属性，总是包含相同对象引用
- 易于理解，更简单
**** 静态工厂方法  
- 不修改API前提下，修改类是否为单例
- 可以改为范型单例工厂
- 可以通过方法引用作为supplier
**** 声明单一元素的枚举类
- 提供了序列化机制：即使在复杂的序列化或反射攻击的情况下，也能防止多个实例
*** 使用私有构造器执行非实例化
如只包含静态方法和静态字段的工具类，不想被实例化
*** 依赖注入优先于硬连接资源 
静态工具类和单例类不适合引用底层资源；应该在创建实例时通过构造器将资源注入
*** 避免创建不必要的对象
- java 正则表达式 Pattern 可以预先编译缓存起来，而不是在每次调用时编译；
- 优先使用基本类型，而不是装箱的基本类型，同时要注意强制类型转换的自动装箱
*** 消除过期的对象引用
一个类自己管理内存时，需要警惕内存泄露，特别是缓存
*** 避免使用Finalizer,Cleaner 机制
*** 使用try-with-resources 代替 try-finally
	资源必须实现 autocloseable 接口
*** 重写equals 方法遵守通用约定 
**** 通用约定
- 自反性：对于非空引用，x.equals(x)为true
- 对称性：对于非空引用，x.equals(y)为true=>y.equals(x)为true
- 传递性
- 一致性：不修改用于equals 比较的信息，x.equals(y)的值始终保持不变
- 对于非空引用，x.equals(null)为false

*** 重写equals 方法同时也要重写hashcode 方法
相等的对象必须具有相同的哈稀码

*** 始终重写tostring 方法 
	
*** 谨慎地重写clone 方法
*** 考虑实现 comparable 接口
*** 使类和成员的可访问性最小
- 让每个类或成员尽可能地不被访问
- 公共类的实例字段很少采用 public 修饰；带有公共可变字段的类通常不是线程安全的
- 非零长度的数组总是可变的，所以类具有公共静态final 数组字段，或者返回这样一个字段的
  访问器是错误的
*** 在公共类中使用访问方法而不是公共属性
*** 最小化可变性
**** 不可变类
实例不可修改的类：string 类,基本类型包装类，BigInteger 类和 BigDecimal 类。
1. 不要提供修改对象状态的方法（setter）
2. 确保这个类不能被继承，使用final 修饰
3. 把所有字段设为private,final
4. 确保对任何组件的互斥访问
**** 不可变对象
- 线程安全不需要同步
- 不仅可以共享不可变对象还可以共享内部信息
- 能为其他对象提供很好的构件
- 无偿提供原子失败机制
- 对于每个值都需要一个对象

*** 组合优先继承
继承打破了封装，

*** 设计继承并提供文档声明，否则禁用继承
构造方法绝不能直接或间接调用可重写的方法

*** 接口优于抽象类
	
*** 为后代设计接口
	
*** 接口仅用来定义类型
- 常量接口是对接口的糟糕使用

*** 类层次结构优先于标签类
	
*** 支持使用静态成员类而不是非静态类
	
*** 将源文件限制为单个顶级类
	
*** 不要使用原始类型
- 使用原始类型，丧失范型所有安全性和表达上的优势

*** 列表优先数组
**** 数组是协变和具体化的，提供运行时类型安全，但不提供编译时安全
**** 范型是不变的，类型擦除，提供编译时安全
*** 优先使用范型
范型比需要在客户端中强制转换的类型更安全，更易于使用
*** 优先使用范型方法
*** 使用限定通配符来增加api 灵活性
为了获得最大的灵活性，对代表生产者和消费者的输入参数使用通配符类型
**** 基本原则
producer-extends,consumer-super(PECS),Comparable 和 Comparator 都是消费者

*** 合理地结合范型和可变参数
*** 优先考虑类型安全的异构容器
*** 使用枚举类型代替整型常量
**** 可以通过构造方法或抽象方法关联数据，行为和枚举实例
*** 使用实例属性代替序数
**** 不要基于枚举的序号得出相关的值，而是将其保存在实例属性
*** 使用 EnumSet 替代位属性
*** 使用 EnumMap 替代序数索引
*** 使用接口来模拟可拓展的枚举
*** 注解优先于命名模式 
**** 命名模式的缺点
- 拼写错误导致失败，不会提示
- 无法确保它们仅用于适当的程序元素
- 没有提供将参数与程序元素相关联的好办法
**** 可以使用注解代替时，没有理由使用命名模式
*** 始终使用 override 注解
*** 使用标记接口定义类型
**** 标记接口
标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型
**** 标记注解
标记注解是特殊类型的注解，其中不包含成员
**** 标记接口的优点
1. 定义了一个由标记类实例实现的类型，标记注解则没有定义
2. 相比标记注解，可以更精确地定位目标
**** 标记注解的优点
作为更大的注解工具的一部分
*** lambda 表达式优于匿名类
lambda 没有名称和文档；如果计算不是自解释的，或超过三行，请不要使用lambda;
除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象
*** 方法引用优于 lambda 表达式
**** 前提
方法引用更简洁更清晰
*** 优先使用标准的函数式接口
*** 谨慎使用 stream
**** 抽象
- 流：有限或无限的数据元素序列
- 流管道：对这些数据元素的多级计算
**** 适用场景
- 统一转换元素序列
- 过滤元素序列
- 使用单个操作组合元素序列
- 对元素序列进行分组
- 在元素序列中搜索

*** 优先考虑流中无副作用的函数 
- forEach 操作应仅用于报告流计算的结果,而不是用于执行计算
  
*** 优先使用 collection 而不是使用 stream 来作为方法返回值
	
*** 谨慎地使用并行流
即使在最好的情况下,如果源来自 Stream.iterate 方法,或者使用中间操作 limit 方法,并行化管道也
不太可能提高其性能

*** 检查参数有效性
	
*** 必要时进行防御性拷贝
	
*** 仔细设计方法签名
**** 仔细选择方法名称
**** 不要过分地提供方便地方法
**** 避免过长的参数列表
- 拆分方法
- 封装为类
**** 参数类型优先使用接口而不是实现类
**** 使用两个元素枚举类型代替布尔型参数
**** 谨慎地使用重载
重载方法之间地选择是静态的，重写方法之间的选择是动态的；
**永远不要导出两个具有相同参数数量的重载**
*** 谨慎地使用可变参数
可变参数机制：数组
*** 返回空的数组或集合，不要返回 null
*** 谨慎地返回 optional
*** 为所有公开的api 添加注释
*** 最小化局部变量的作用域
*** 增强for 循环犹豫传统for 循环
