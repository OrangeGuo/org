#+title:effective-java
*** 考虑使用静态工厂方法代替构造方法
**** 静态工厂方法可以通过选择名字体现差异，更易于理解
**** 可以直接调用，无需事先创建对象
**** 可以返回 返回类型 的任何子类型对象
API可以返回对象而不需要公开它的类，从而隐藏实现类
**** 返回对象的类可以根据输入参数的不同而不同 
根据需要来选择合适的类来生成返回对象，从而优化性能
*** 构造方法参数过多时使用builder模式
*** 使用私有构造方法或枚举类实现singleton属性
**** 公共属性方法
- 单例是公共final 静态属性，总是包含相同对象引用
- 易于理解，更简单
**** 静态工厂方法  
- 不修改API前提下，修改类是否为单例
- 可以改为范型单例工厂
- 可以通过方法引用作为supplier
**** 声明单一元素的枚举类
- 提供了序列化机制：即使在复杂的序列化或反射攻击的情况下，也能防止多个实例
*** 使用私有构造器执行非实例化
如只包含静态方法和静态字段的工具类，不想被实例化
*** 依赖注入优先于硬连接资源 
静态工具类和单例类不适合引用底层资源；应该在创建实例时通过构造器将资源注入
*** 避免创建不必要的对象
- java 正则表达式 Pattern 可以预先编译缓存起来，而不是在每次调用时编译；
- 优先使用基本类型，而不是装箱的基本类型，同时要注意强制类型转换的自动装箱
*** 消除过期的对象引用
一个类自己管理内存时，需要警惕内存泄露，特别是缓存
*** 避免使用Finalizer,Cleaner 机制
*** 使用try-with-resources 代替 try-finally
	资源必须实现 autocloseable 接口
*** 重写equals 方法遵守通用约定 
**** 通用约定
- 自反性：对于非空引用，x.equals(x)为true
- 对称性：对于非空引用，x.equals(y)为true=>y.equals(x)为true
- 传递性
- 一致性：不修改用于equals 比较的信息，x.equals(y)的值始终保持不变
- 对于非空引用，x.equals(null)为false

*** 重写equals 方法同时也要重写hashcode 方法
相等的对象必须具有相同的哈稀码

*** 始终重写tostring 方法 
	
*** 谨慎地重写clone 方法
*** 考虑实现 comparable 接口
*** 使类和成员的可访问性最小
- 让每个类或成员尽可能地不被访问
- 公共类的实例字段很少采用 public 修饰；带有公共可变字段的类通常不是线程安全的
- 非零长度的数组总是可变的，所以类具有公共静态final 数组字段，或者返回这样一个字段的
  访问器是错误的
*** 在公共类中使用访问方法而不是公共属性
*** 最小化可变性
**** 不可变类
实例不可修改的类：string 类,基本类型包装类，BigInteger 类和 BigDecimal 类。
1. 不要提供修改对象状态的方法（setter）
2. 确保这个类不能被继承，使用final 修饰
3. 把所有字段设为private,final
4. 确保对任何组件的互斥访问
**** 不可变对象
- 线程安全不需要同步
- 不仅可以共享不可变对象还可以共享内部信息
- 能为其他对象提供很好的构件
- 无偿提供原子失败机制
- 对于每个值都需要一个对象

*** 组合优先继承
继承打破了封装，

*** 设计继承并提供文档声明，否则禁用继承
构造方法绝不能直接或间接调用可重写的方法

*** 接口优于抽象类
	
*** 为后代设计接口
	
*** 接口仅用来定义类型
- 常量接口是对接口的糟糕使用

*** 类层次结构优先于标签类
	
*** 支持使用静态成员类而不是非静态类
	
*** 将源文件限制为单个顶级类
	
*** 不要使用原始类型
- 使用原始类型，丧失范型所有安全性和表达上的优势

