#+title:effective-java
*** 考虑使用静态工厂方法代替构造方法
**** 静态工厂方法可以通过选择名字体现差异，更易于理解
**** 可以直接调用，无需事先创建对象
**** 可以返回 返回类型 的任何子类型对象
API可以返回对象而不需要公开它的类，从而隐藏实现类
**** 返回对象的类可以根据输入参数的不同而不同 
根据需要来选择合适的类来生成返回对象，从而优化性能
*** 构造方法参数过多时使用builder模式
*** 使用私有构造方法或枚举类实现singleton属性
**** 公共属性方法
- 单例是公共final 静态属性，总是包含相同对象引用
- 易于理解，更简单
**** 静态工厂方法  
- 不修改API前提下，修改类是否为单例
- 可以改为范型单例工厂
- 可以通过方法引用作为supplier
**** 声明单一元素的枚举类
- 提供了序列化机制：即使在复杂的序列化或反射攻击的情况下，也能防止多个实例
*** 使用私有构造器执行非实例化
如只包含静态方法和静态字段的工具类，不想被实例化
*** 依赖注入优先于硬连接资源 
静态工具类和单例类不适合引用底层资源；应该在创建实例时通过构造器将资源注入
*** 避免创建不必要的对象
- java 正则表达式 Pattern 可以预先编译缓存起来，而不是在每次调用时编译；
- 优先使用基本类型，而不是装箱的基本类型，同时要注意强制类型转换的自动装箱
*** 消除过期的对象引用
一个类自己管理内存时，需要警惕内存泄露，特别是缓存
*** 避免使用Finalizer,Cleaner 机制
*** 使用try-with-resources 代替 try-finally
	资源必须实现 autocloseable 接口

